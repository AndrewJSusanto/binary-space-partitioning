// room.c
#include <cairo.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <math.h>
#include <limits.h>
#include "Wall.h"
#include "List.h"
#include "BSP.h"


// Two line segments are equal if they start and end at the same point
// Returns 0 if segments are equal, -1 otherwise
int SegmentsEqual(void* segment1, void* segment2){
	segment* seg1 = (segment*)segment1;
	segment* seg2 = (segment*)segment2;

	if(seg1->start->x == seg2->start->x && seg1->end->x == seg2->end->x && seg1->start->y == seg2->start->y && seg1->end->y == seg2->end->y) {
		return 0;
	}
	else {
		return -1;
	}
}

// Returns 0 if points are equal, -1 otherwise
int PointsEqual(void* point1, void* point2) {
    point* p1 = (point*)point1;
    point* p2 = (point*)point2;

    if(p1->x == p2->x && p1->y == p2->y) {
        return 0;
    }
    else {
        return -1;
    }
}

//print out the coordinates of the segment, remember to use %d for integers
void PrintSegment(void* segment1){
	segment* seg1 = (segment*)segment1;
	printf("%d %d %d %d\n", seg1->start->x, seg1->start->y, seg1->end->x, seg1->end->y);
}

void PrintPoint(void* pt) {
    point* p1 = (point*)pt;
    printf("%d %d\n", p1->x, p1->y);
}

// remember to free the start and end points of the segment
void DestroySegment(segment* seg){
	free(seg->start);
	free(seg->end);
	free(seg);
}

// free point
void DestroyPoint(point* pt) {
    free(pt);
}

// onSegment determines whether or not a point* pt lies within the segment generated by point* w1 and w2. Takes into account situations where w1 < w2, and vice versa. Returns true if pt lies on the segment, else false.
bool onSegment(point* w1, point* pt, point* w2) { // checks if pt is within seg->start and seg->end 
	int maxwx, maxwy, minwx, minwy;

	if(w1->x >= w2->x) { // determine max and min for x and y of w1,w2
		maxwx = w1->x;
		minwx = w2->x;
	}
	else {
		maxwx = w2->x;
		minwx = w1->x;
	}

	if(w1->y >= w2->y) {
		maxwy = w1->y;
		minwy = w2->y;
	}
	else {
		maxwy = w2->y;
		minwy = w1->y;
	}

    if(pt->x <= maxwx && pt->x >= minwx && pt->y <= maxwy && pt->y >= minwy) { // if w1 and w2 enclose pt, return true
        return true;
    }
    return false;
}


// function that determines whether or not a door is enclosed by walls. Uses the odd or even method by creating an infinitely long segment
//that extends out of point* door and calculates the number of intersections generated between that segment and the surrounding walls. 
// returns true if the intersections were odd (meaning the point is inside), and false if even (door outside). 
bool inside(ListPtr* walls, point* door) { // check if door is within wall
    point* extend = point_create(INT_MAX, door->y);
    segment* infinite = segment_create(door, extend);
	point* temp1 = point_create(0, 0);
	point* temp2 = point_create(0, 1);
	segment* wall = segment_create(temp1, temp2);
	point* temp = point_create(0, 0);
	int count = 0;
	

    for(unsigned int i = 0; i < list_length(walls); i++) { // iterate over every wall, compare with the infinite segment, determine how many intersections occur.
		wall = list_get_index(walls, i);
		
		// if door is on left of wall
			// if door.y is within wall->s->y and wall->e->y
				// if classifysegment returns straddling
					//increment count

		if(door->x < wall->start->x && wall->orientation == VERTICAL) {
			if((door->y > wall->start->y && door->y < wall->end->y) || (door->y < wall->start->y && door->y > wall->end->y)) {
				if(ClassifySegment(*infinite, *wall) == SEGMENT_WALL_SIDE_STRADDLING) {
					count++;
				}
			}
		}
	}
	if(count % 2 == 0) { // if intersections is even, then the point is outside, else inside
		return false; // outside
	}
	else {
		return true; // inside
	}
}

/*
Takes a parent node and generates a list containing all elements that form the left subtree of parent
Note: The original list should be modified so that it contains only elements that form the right subtree of parent
Assumes that parent is not in original
*/

// parent is a treenode or segment, depending on implementation
// remaining is a list of segments
ListPtr GetPartitions(void* parent, ListPtr remaining){
	// cast void* parent as a segment to use for partitioning. Iterate through in loop remaining list and call ClassifySegment for each wall in the list.
	// in loop, if node in list is front, append into list to be returned.
	// if node in list is back, append into other list to be placinto remaied ning.

	if(parent == NULL || remaining == NULL) {
		return NULL;
	}

	segment* pseg = (segment*)parent;
	ListPtr back = list_create(SegmentsEqual, PrintSegment, DestroySegment); // ListPtr to be returned
	segment* index = (segment*)malloc(sizeof(segment));

	for(unsigned int i = 0; i < list_length(remaining); i++) { // Iterate over remaining list
		index = (segment*)list_get_index(remaining, i); // looks at the segment held in the head of list
		enum ESegmentWallSide type = ClassifySegment(*pseg, *index); // checks class of the wall
		if(type == SEGMENT_WALL_SIDE_FRONT) { // 
			// do nothing, leave in the remaining list because we want remaining to contain all the right subtree nodes in the end
			list_append(back, index); // put wall into back
			list_del_index(remaining, list_find_element(remaining, index)); // delete the original segment in remaining
			i--; // decrement i to avoid skipping the next element in line, as it shifts forward one index after deletion of the original segment.
		}
		else if(type == SEGMENT_WALL_SIDE_BEHIND) { // if type is behind, insert into back list, remove from remaining, --remlength
		}
		else if(type == SEGMENT_WALL_SIDE_STRADDLING) { // if straddle, split into front and back seg; insert front seg into front list, back seg into back list.
			point* temp1 = point_create(0, 0);
			point* temp2 = point_create(0, 1);
			segment* frontSeg =  segment_create(temp1, temp2);
			segment* backSeg = segment_create(temp1, temp2);
			SplitWallSegment(*pseg, *index, frontSeg, backSeg); // Splits current wall into two segments
			int pos = list_find_element(remaining, index);
			list_del_index(remaining, pos); // deletes original segment
			list_insert(remaining, pos, frontSeg); // inserts front half of segment into the original's index (used for right subtree)
			list_append(back, backSeg); // inserts back half of segment into a list to be used to form the left subtree
		}
	}
	return back;
}

// remaining is a list of segments, returns a segment that is in the middle of the list, at floor(list_length/2) - 1
void* SelectPartitionRoot(ListPtr remaining){
	segment* proot = (segment*)malloc(sizeof(segment));
	if(list_length(remaining) == 0) {
		return NULL;
	}
	int wall_index = floor(list_length(remaining) / 2);
	if(wall_index == 0) {
		proot = (segment*)list_del_index(remaining, 0);
	}
	else {
		proot = (segment*)list_del_index(remaining, wall_index - 1);
	}
	return proot;
}


int FindFancyDoor(BSPTree* tree, segment fancydoor, segment* Wall);



//Determines which wall the door is located on using bsp tree
//The door is a point with given coordinates
int FindDoor(BSPTree* tree, point door, segment* Wall) {
	//build a list of walls
	//create variable to hold a counter for the number of intersections/
	//create a door segment from (doorx, doory) (INT_MAX, doory)
	//loop through the list of walls
	//check orientation of wall
	//if horizontal:
				//check if the point is on the wall. If it is then set segment *Wall to said segment and return 1
	//if vertical:
				//check if the point is on the wall. If it is the set segment *Wall to said segment and return 1
				//if the door is to the left of the wall:
					//if classify segment with the door segment and wall is straddling
					//increment the intersection counter
	//if the intersection counter is an odd number door is in
	//else door is out

	ListPtr walls = BSP_GetTraversal(tree); 

	int check = 0; //
	for(unsigned int i = 0; i < list_length(walls); i++) {
		segment* wall = list_get_index(walls, i);
		if(wall != NULL) {
			if(onSegment(wall->start, &door, wall->end)) {

				//printf("\t\tDoor is on segment. \n");
				Wall->start->x = wall->start->x;
				Wall->start->y = wall->start->y;
				Wall->end->x = wall->end->x;
				Wall->end->y = wall->end->y;
				return 0;
			}
		}
	}
	if(inside(walls, &door)) {
		return 1;
	}
	else {
		return -1;
	}
}


/**
 * @brief Used to draw out our BSP (room)
 *
 * @param tree A pointer to the tree containing the room
 * @param filename The name of the outputfile, DrawBSP concatenates with ".png"
 * @param doors A list of doors (points) that will be drawn to the cairo canvas in red
 * @param fancyDoors A list of fancyDoors (segments) that will be drawn to the cairo canvas in yellow
 *
 */
void DrawBSP(BSPTree* tree, char* filename, ListPtr doors, ListPtr fancyDoors){
	// Get a list of our BSP data sorted by pre-order traversal
	ListPtr traversalList = BSP_GetTraversal(tree);
	cairo_surface_t *surface = cairo_image_surface_create (CAIRO_FORMAT_ARGB32, 512, 512);
	cairo_t *cr = cairo_create (surface);
	cairo_set_source_rgb(cr, 0, 0, 0);
	cairo_rectangle(cr, 0, 0, 512, 512);
	cairo_fill(cr);
	cairo_set_source_rgb(cr, 1, 1, 1);
	cairo_set_line_width(cr, 5.0);
	cairo_set_font_size(cr, 32);
	char label[10];
	for(int i = 0; i < list_length(traversalList); i++){
		segment* seg = (segment*)list_get_index(traversalList, i);
		//draw the line
		cairo_move_to(cr, seg->start->x, seg->start->y);
		cairo_line_to(cr, seg->end->x, seg->end->y);
		cairo_stroke(cr);
		int midX = (seg->start->x + seg->end->x)/2;
		int midY = (seg->start->y + seg->end->y)/2;
		cairo_move_to(cr, midX, midY);
		sprintf(label, "%d", i);
		cairo_show_text(cr, label);
	}
	
	if(doors != NULL){
		cairo_close_path(cr);
		cairo_set_source_rgb(cr, 1, 0, 0);
		for(int i = 0; i < list_length(doors); i++){
			point* d = (point*)list_get_index(doors, i);
			cairo_rectangle(cr, (d->x) - 5, (d->y) - 5, 10, 10);
			cairo_stroke(cr);
		}
	}

	if(fancyDoors != NULL){
		cairo_set_source_rgb(cr, 1, 1, 0);
		for(int i = 0; i < list_length(fancyDoors); i++){
			segment* seg = (segment*)list_get_index(fancyDoors, i);
			//draw the line
			cairo_move_to(cr, seg->start->x, seg->start->y);
			cairo_line_to(cr, seg->end->x, seg->end->y);
			cairo_close_path(cr);
			cairo_stroke(cr);
		}
	}

	cairo_destroy(cr);
	char* outputName = strcat(filename, ".png");
	cairo_surface_write_to_png(surface, outputName);
	cairo_surface_destroy(surface);
}

// argv[0] = prog4, argv[1] = "room.in", argv[2] = "door.in"
int main (int argc, char **argv){
	char room[BUFSIZ] = ""; // stores title of the 
	char coordinates[BUFSIZ] = "";
	char delim[BUFSIZ] = " \n"; // delimiter set to space
	ListPtr walls = list_create(SegmentsEqual, PrintSegment, DestroySegment);
    int x1, y1, x2, y2;

    FILE *rf = fopen(argv[1], "r"); // file open for room infile
    fscanf(rf, "%s", room);
    while(fscanf(rf, "%d %d %d %d", &x1, &y1, &x2, &y2) != EOF) { // Read from room infile, store each line as segments into list
        point* start = point_create(x1, y1);
		point* end = point_create(x2, y2);

		segment* wall = segment_create(start, end);
		list_append(walls, wall);
    }
    BSPTree *tree = BSP_Create(walls, SelectPartitionRoot, GetPartitions, SegmentsEqual, PrintSegment, DestroySegment); // list used to create BSP tree.
    ListPtr fancy = list_create(SegmentsEqual, PrintSegment, DestroySegment); // dummy ListPtr, no Fancy Door implementation
	fclose(rf);


    FILE *df = fopen(argv[2], "r"); // file open for door infile
    int type; // type of door
    fscanf(df, "%d", &type);
    int dx1, dy1; // set of points for door
    int fdx2, fdy2; // secondary set of points for fancy doors
	ListPtr doors = list_create(PointsEqual, PrintPoint, DestroyPoint);

    while(fscanf(df, "%d %d", &dx1, &dy1) != EOF) { // Read from door infile, store each door as points into list
        point* door = point_create(dx1, dy1);
        list_append(doors, door);
    }


	int where = 0;
	point* temp1 = point_create(0,0);
	point* temp2 = point_create(0,1);

	for(unsigned i = 0; i < list_length(doors); i++) { // throughout this loop, iterate over every door and determine their positioning in reference to the list of walls.
		point* door = list_get_index(doors, i);
		segment* wall = segment_create(temp1, temp2);
		where = FindDoor(tree, *door, wall);
		if(where == 0) {
			printf("%d %d %d %d\n", wall->start->x, wall->start->y, wall->end->x, wall->end->y);
		}
		else if(where == 1) {
			printf("IN\n");
		}
		else if(where == -1) {
			printf("OUT\n");
		}
	}

	DrawBSP(tree, room, doors, fancy);

    fclose(df);

	DestroyTree(tree, true);
	return 0;
}